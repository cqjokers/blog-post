---
title: JAVA并发编程中的三个概念
tags:
  - thread
  - volatile
categories:
  - java
abbrlink: 6208b7fd
date: 2018-07-20 00:00:00
---
## 原子性
***
原子性就是对数据的操作是独立的不能被分成几个步骤完成也就是不能进行分割，当前操作要么全部执行并且执行的过程不会被任何因素打断，要么就全部都不执行。最典型的例子就是平时经常用的`i++`操作，其实这一操作是分为三个步骤完成的：
1、 读取整数 i 的值；
2、 对 i 进行加一操作；
3、 将结果写回内存
如果这三步骤操作在单线程中执行是完全没有问题的，但是如果在多线程执行则会遇见意想不到的结果，为了保证是原子操作我们可以使用同步技术（sychronized）和加锁机制（lock )来让它变成一个原子操作。还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。
<!--more-->
## 可见性
***
由[JAVA内存模型](https://cqjokers.top/2018/07/19/java/JMM/)我们知道，所有数据都是先从主内存中加载到工作内存中，对数据进行修改后是先更新工作内存然后才是更新到主内存中，假如在一个线程修改数据后还未更新到主内存中时，而另外一个线程此时去加载了该数据那么此时得到的就是之前的旧数据。
　　对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去主内存中读取新值。相返未使用volatile来修饰的变量则不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主内存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
　　如果想要普通变量也能保证可见性可以通过synchronized和Lock来保证，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
## 有序性
***
有序性：即程序执行的顺序按照代码的先后顺序执行。看下面这段代码：
```JAVA
int a = 10;
int b = 20;
a = a - 2;
b = a * b;
```
按照正常逻辑执行的顺序是：1>2>3>4,但是由于处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的，所以上面的执行顺序很有可能是：2>1>3>4,由于处理器在进行重排序时是会考虑指令之间的数据依赖性，如果后面的操作会依赖前面操作的结果，那么就会先执行前面的操作。虽然重排序在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。

Java 中可以使用 volatile 来保证顺序性，synchronize 和 lock 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。

除了通过 volatile 关键字显式的保证顺序之外， JVM 还通过 happen-before 原则来隐式的保证顺序性。happens-before原则规则如下：参考->[死磕Java并发](http://cmsblogs.com/?p=2102)
>* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
>* 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
>* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
>* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
>* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
>* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
>* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
>* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；
